package com.bscan.service

import android.content.Context
import android.util.Log
import com.bscan.detector.TagDetector
import com.bscan.model.Component
import com.bscan.model.DecryptedScanData
import com.bscan.model.TagFormat
import com.bscan.repository.UserComponentRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.LocalDateTime

/**
 * Service that generates components on-demand from scan data.
 * Components generated by this service are NEVER persisted - they are created fresh each time.
 * This allows the generation logic to be updated without breaking existing data.
 */
class ComponentGenerationService(private val context: Context) {
    
    private val tagDetector = TagDetector()
    
    // Required repositories for interpreters
    private val catalogRepository by lazy { com.bscan.repository.CatalogRepository(context) }
    private val userDataRepository by lazy { com.bscan.repository.UserDataRepository(context) }
    private val unifiedDataAccess by lazy { com.bscan.repository.UnifiedDataAccess(catalogRepository, userDataRepository) }
    private val filamentMappings by lazy { com.bscan.model.FilamentMappings() }
    
    // User component system for overlays and user-created components
    private val userComponentRepository by lazy { UserComponentRepository(context) }
    private val componentMergerService by lazy { ComponentMergerService() }
    
    // Component factories - these should NOT persist components
    private val bambuFactory by lazy { BambuComponentFactory(context) }
    private val crealityFactory by lazy { CrealityComponentFactory(context) }
    private val openTagFactory by lazy { OpenTagComponentFactory(context) }
    private val genericFactory by lazy { GenericComponentFactory(context) }
    
    companion object {
        private const val TAG = "ComponentGenerationService"
    }
    
    /**
     * Generate all components from stored scan data.
     * Returns fresh components every time - nothing is persisted.
     */
    suspend fun generateComponentsFromScans(scans: List<DecryptedScanData>): List<Component> = withContext(Dispatchers.IO) {
        Log.d(TAG, "Generating components from ${scans.size} scans")
        
        val allComponents = mutableListOf<Component>()
        val processedTrays = mutableSetOf<String>()
        
        // Process each scan
        scans.forEach { scan ->
            try {
                // For Bambu scans, check if we've already processed this tray
                val shouldSkip = when (scan.tagFormat) {
                    TagFormat.BAMBU_PROPRIETARY -> {
                        val interpreter = com.bscan.interpreter.BambuFormatInterpreter(filamentMappings, unifiedDataAccess)
                        val trayUid = interpreter.interpret(scan)?.trayUid
                        if (trayUid != null && processedTrays.contains(trayUid)) {
                            true // Skip - already processed this tray
                        } else {
                            trayUid?.let { processedTrays.add(it) }
                            false
                        }
                    }
                    else -> false
                }
                
                if (!shouldSkip) {
                    val components = generateComponentsFromScan(scan)
                    allComponents.addAll(components)
                    Log.d(TAG, "Generated ${components.size} components from scan ${scan.tagUid}")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error generating components from scan ${scan.tagUid}", e)
            }
        }
        
        Log.d(TAG, "Generated total of ${allComponents.size} components from ${scans.size} scans")
        
        // Apply user overlays and user-created components
        val userOverlays = userComponentRepository.getAllOverlays()
        val mergedComponents = componentMergerService.mergeComponents(allComponents.toList(), userOverlays)
        
        Log.d(TAG, "Applied ${userOverlays.size} user overlays, final component count: ${mergedComponents.size}")
        mergedComponents
    }
    
    /**
     * Generate components from a single scan.
     * Uses appropriate factory based on detected tag format.
     */
    private suspend fun generateComponentsFromScan(scan: DecryptedScanData): List<Component> {
        return when (scan.tagFormat) {
            TagFormat.BAMBU_PROPRIETARY -> {
                // Interpret the scan data first
                val interpreter = com.bscan.interpreter.BambuFormatInterpreter(filamentMappings, unifiedDataAccess)
                val filamentInfo = interpreter.interpret(scan)
                if (filamentInfo != null) {
                    bambuFactory.createComponents(scan.tagUid, filamentInfo, emptyMap())
                } else {
                    emptyList()
                }
            }
            
            TagFormat.CREALITY_ASCII -> {
                // Interpret Creality data
                val interpreter = com.bscan.interpreter.CrealityFormatInterpreter()
                val crealityInfo = interpreter.interpret(scan)
                if (crealityInfo != null) {
                    crealityFactory.createComponents(scan.tagUid, crealityInfo, emptyMap())
                } else {
                    emptyList()
                }
            }
            
            TagFormat.OPENTAG_V1 -> {
                // Interpret OpenTag data
                val interpreter = com.bscan.interpreter.OpenTagInterpreter()
                val openTagInfo = interpreter.interpret(scan)
                if (openTagInfo != null) {
                    openTagFactory.createComponents(scan.tagUid, openTagInfo, emptyMap())
                } else {
                    emptyList()
                }
            }
            
            TagFormat.NDEF_JSON, 
            TagFormat.NDEF_URI, 
            TagFormat.PROPRIETARY, 
            TagFormat.USER_DEFINED, 
            TagFormat.UNKNOWN -> {
                genericFactory.createComponents(scan.tagUid, scan, emptyMap())
            }
        }
    }
    
    /**
     * Generate components for a specific tray UID.
     * Useful for inventory detail views.
     */
    suspend fun generateComponentsForTray(trayUid: String, scans: List<DecryptedScanData>): List<Component> = withContext(Dispatchers.IO) {
        val trayScans = scans.filter { scan ->
            try {
                when (scan.tagFormat) {
                    TagFormat.BAMBU_PROPRIETARY -> {
                        val interpreter = com.bscan.interpreter.BambuFormatInterpreter(filamentMappings, unifiedDataAccess)
                        interpreter.interpret(scan)?.trayUid == trayUid
                    }
                    else -> false
                }
            } catch (e: Exception) {
                Log.w(TAG, "Error checking tray UID for scan", e)
                false
            }
        }
        
        if (trayScans.isNotEmpty()) {
            generateComponentsFromScans(trayScans)
        } else {
            emptyList()
        }
    }
    
    /**
     * Check if we have scan data for a specific tray UID
     */
    fun hasScanDataForTray(trayUid: String, scans: List<DecryptedScanData>): Boolean {
        return scans.any { scan ->
            try {
                when (scan.tagFormat) {
                    TagFormat.BAMBU_PROPRIETARY -> {
                        val interpreter = com.bscan.interpreter.BambuFormatInterpreter(filamentMappings, unifiedDataAccess)
                        interpreter.interpret(scan)?.trayUid == trayUid
                    }
                    else -> false
                }
            } catch (e: Exception) {
                false
            }
        }
    }
}

// Extension function for ByteArray to hex string (if not already available)
private fun ByteArray.toHex(): String {
    return joinToString("") { "%02x".format(it) }
}