name: Auto Release

on:
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

jobs:
  # Generate changelog and create release directly
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for changelog generation
      
      - name: Setup Android environment
        uses: ./.github/actions/setup-android
      
      - name: Get next version
        id: version
        run: |
          # Get current version from version.txt or start with 1.0.0
          CURRENT_VERSION=$(cat version.txt 2>/dev/null || echo "1.0.0")
          
          # Get commits since last tag (or all if no tags)
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -n "$LAST_TAG" ]; then
            COMMITS_RANGE="$LAST_TAG..HEAD"
          else
            COMMITS_RANGE="HEAD"
          fi
          
          # Check for breaking changes, features, or fixes (excluding version bump commits)
          HAS_BREAKING=$(git log --pretty=format:"%s %b" $COMMITS_RANGE | grep -v "bump version to" | grep -v "\[skip ci\]" | grep -E "(BREAKING CHANGE|!:)" || true)
          HAS_FEAT=$(git log --pretty=format:"%s" $COMMITS_RANGE | grep -v "bump version to" | grep -v "\[skip ci\]" | grep -E "^feat" || true)
          HAS_FIX=$(git log --pretty=format:"%s" $COMMITS_RANGE | grep -v "bump version to" | grep -v "\[skip ci\]" | grep -E "^fix" || true)
          
          # Parse current version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Determine version bump
          if [ -n "$HAS_BREAKING" ]; then
            NEW_VERSION="$((MAJOR + 1)).0.0"
          elif [ -n "$HAS_FEAT" ]; then
            NEW_VERSION="$MAJOR.$((MINOR + 1)).0"
          elif [ -n "$HAS_FIX" ]; then
            NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
          else
            # No significant changes, patch bump for any commits
            if [ "$(git rev-list --count $COMMITS_RANGE)" -gt 0 ]; then
              NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
            else
              echo "No commits to release"
              echo "skip_release=true" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "version_code=${{ github.run_number }}" >> $GITHUB_OUTPUT
          echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
          
          echo "Version bump: $CURRENT_VERSION â†’ $NEW_VERSION"
      
      - name: Generate changelog
        id: changelog
        if: steps.version.outputs.skip_release != 'true'
        run: |
          # Get commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -n "$LAST_TAG" ]; then
            COMMITS_RANGE="$LAST_TAG..HEAD"
            echo "Generating changelog from $LAST_TAG to HEAD"
          else
            COMMITS_RANGE="HEAD"
            echo "Generating changelog for all commits"
          fi
          
          # Get all commits excluding version bump commits
          ALL_COMMITS=$(git log --pretty=format:"%s" $COMMITS_RANGE --reverse | grep -v "bump version to" | grep -v "\[skip ci\]")
          
          # Initialize sections
          BREAKING_CHANGES=""
          FEAT_COMMITS=""
          FIX_COMMITS=""
          PERF_COMMITS=""
          REFACTOR_COMMITS=""
          DOCS_COMMITS=""
          TEST_COMMITS=""
          BUILD_COMMITS=""
          CI_COMMITS=""
          CHORE_COMMITS=""
          STYLE_COMMITS=""
          REVERT_COMMITS=""
          OTHER_COMMITS=""
          
          # Parse commits by type
          while IFS= read -r commit; do
            # Skip empty commits and version bump commits
            if [[ -z "$commit" || "$commit" =~ "bump version to" || "$commit" =~ "\[skip ci\]" ]]; then
              continue
            fi
            
            # Check for breaking changes first
            if [[ $commit =~ BREAKING\ CHANGE || $commit =~ !: ]]; then
              desc=$(echo "$commit" | sed 's/^[^:]*: //')
              BREAKING_CHANGES="${BREAKING_CHANGES}- ${desc}\n"
            elif [[ $commit =~ ^feat ]]; then
              desc=$(echo "$commit" | sed 's/^feat[^:]*: //')
              FEAT_COMMITS="${FEAT_COMMITS}- ${desc}\n"
            elif [[ $commit =~ ^fix ]]; then
              desc=$(echo "$commit" | sed 's/^fix[^:]*: //')
              FIX_COMMITS="${FIX_COMMITS}- ${desc}\n"
            elif [[ $commit =~ ^perf ]]; then
              desc=$(echo "$commit" | sed 's/^perf[^:]*: //')
              PERF_COMMITS="${PERF_COMMITS}- ${desc}\n"
            elif [[ $commit =~ ^refactor ]]; then
              desc=$(echo "$commit" | sed 's/^refactor[^:]*: //')
              REFACTOR_COMMITS="${REFACTOR_COMMITS}- ${desc}\n"
            elif [[ $commit =~ ^docs ]]; then
              desc=$(echo "$commit" | sed 's/^docs[^:]*: //')
              DOCS_COMMITS="${DOCS_COMMITS}- ${desc}\n"
            elif [[ $commit =~ ^test ]]; then
              desc=$(echo "$commit" | sed 's/^test[^:]*: //')
              TEST_COMMITS="${TEST_COMMITS}- ${desc}\n"
            elif [[ $commit =~ ^build ]]; then
              desc=$(echo "$commit" | sed 's/^build[^:]*: //')
              BUILD_COMMITS="${BUILD_COMMITS}- ${desc}\n"
            elif [[ $commit =~ ^ci ]]; then
              desc=$(echo "$commit" | sed 's/^ci[^:]*: //')
              CI_COMMITS="${CI_COMMITS}- ${desc}\n"
            elif [[ $commit =~ ^chore ]]; then
              desc=$(echo "$commit" | sed 's/^chore[^:]*: //')
              CHORE_COMMITS="${CHORE_COMMITS}- ${desc}\n"
            elif [[ $commit =~ ^style ]]; then
              desc=$(echo "$commit" | sed 's/^style[^:]*: //')
              STYLE_COMMITS="${STYLE_COMMITS}- ${desc}\n"
            elif [[ $commit =~ ^revert ]]; then
              desc=$(echo "$commit" | sed 's/^revert[^:]*: //')
              REVERT_COMMITS="${REVERT_COMMITS}- ${desc}\n"
            else
              OTHER_COMMITS="${OTHER_COMMITS}- ${commit}\n"
            fi
          done <<< "$ALL_COMMITS"
          
          # Build changelog
          CHANGELOG=""
          if [ -n "$BREAKING_CHANGES" ]; then
            CHANGELOG="${CHANGELOG}## âš ï¸ BREAKING CHANGES\n${BREAKING_CHANGES}\n"
          fi
          if [ -n "$FEAT_COMMITS" ]; then
            CHANGELOG="${CHANGELOG}## ðŸš€ Features\n${FEAT_COMMITS}\n"
          fi
          if [ -n "$FIX_COMMITS" ]; then
            CHANGELOG="${CHANGELOG}## ðŸ› Bug Fixes\n${FIX_COMMITS}\n"
          fi
          if [ -n "$PERF_COMMITS" ]; then
            CHANGELOG="${CHANGELOG}## âš¡ Performance Improvements\n${PERF_COMMITS}\n"
          fi
          if [ -n "$REFACTOR_COMMITS" ]; then
            CHANGELOG="${CHANGELOG}## â™»ï¸ Code Refactoring\n${REFACTOR_COMMITS}\n"
          fi
          if [ -n "$DOCS_COMMITS" ]; then
            CHANGELOG="${CHANGELOG}## ðŸ“š Documentation\n${DOCS_COMMITS}\n"
          fi
          if [ -n "$TEST_COMMITS" ]; then
            CHANGELOG="${CHANGELOG}## ðŸ§ª Tests\n${TEST_COMMITS}\n"
          fi
          if [ -n "$BUILD_COMMITS" ]; then
            CHANGELOG="${CHANGELOG}## ðŸ—ï¸ Build System\n${BUILD_COMMITS}\n"
          fi
          if [ -n "$CI_COMMITS" ]; then
            CHANGELOG="${CHANGELOG}## ðŸ‘· Continuous Integration\n${CI_COMMITS}\n"
          fi
          if [ -n "$CHORE_COMMITS" ]; then
            CHANGELOG="${CHANGELOG}## ðŸ”§ Chores\n${CHORE_COMMITS}\n"
          fi
          if [ -n "$STYLE_COMMITS" ]; then
            CHANGELOG="${CHANGELOG}## ðŸ’„ Styling\n${STYLE_COMMITS}\n"
          fi
          if [ -n "$REVERT_COMMITS" ]; then
            CHANGELOG="${CHANGELOG}## âª Reverts\n${REVERT_COMMITS}\n"
          fi
          if [ -n "$OTHER_COMMITS" ]; then
            CHANGELOG="${CHANGELOG}## Other Changes\n${OTHER_COMMITS}\n"
          fi
          
          # Save changelog to file
          echo -e "$CHANGELOG" > changelog.md
          echo "Generated changelog with $(echo -e "$CHANGELOG" | wc -l) lines"
      
      - name: Build release artifacts
        if: steps.version.outputs.skip_release != 'true'
        run: |
          ./gradlew assembleRelease bundleRelease \
            -PversionName=${{ steps.version.outputs.new_version }} \
            -PversionCode=${{ steps.version.outputs.version_code }} \
            --parallel --build-cache --configuration-cache
      
      - name: Create release
        if: steps.version.outputs.skip_release != 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Update version.txt
          echo "${{ steps.version.outputs.new_version }}" > version.txt
          
          # Create release notes with dynamic date
          BUILD_DATE=$(date -u +'%Y-%m-%d %H:%M:%S UTC')
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          cat > release_notes.md << EOF
          ## ðŸ“± Download
          Download the appropriate file for your device:
          - **APK**: For direct installation on Android devices
          - **AAB**: For distribution via Google Play Store
          
          ## ðŸ“‹ Requirements
          - Android 10+ (API 29)
          - NFC-enabled device with NFC enabled
          
          ## What's Changed
          
          EOF
          
          # Append generated changelog
          if [ -f changelog.md ]; then
            cat changelog.md >> release_notes.md
          fi
          
          # Rename artifacts with version numbers
          VERSION="${{ steps.version.outputs.new_version }}"
          cp app/build/outputs/apk/release/app-release.apk "b-scan-${VERSION}.apk"
          cp app/build/outputs/bundle/release/app-release.aab "b-scan-${VERSION}.aab"
          
          # Create GitHub release with versioned filenames
          gh release create ${{ steps.version.outputs.tag }} \
            --title "B-Scan ${{ steps.version.outputs.new_version }}" \
            --notes-file release_notes.md \
            "b-scan-${VERSION}.apk" \
            "b-scan-${VERSION}.aab"
          
          echo "âœ… Created release ${{ steps.version.outputs.tag }}"
      
      - name: Update version file
        if: steps.version.outputs.skip_release != 'true'
        run: |
          # Commit version bump back to repository
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add version.txt
          git commit -m "chore: bump version to ${{ steps.version.outputs.new_version }} [skip ci]" || exit 0
          git push